/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Account {
    'code': number;
    'message'?: string;
    'account_type': number;
    'index': number;
    'l1_address': string;
    'cancel_all_time': number;
    'total_order_count': number;
    'total_isolated_order_count': number;
    'pending_order_count': number;
    'available_balance': string;
    'status': number;
    'collateral': string;
}
export interface AccountApiKeys {
    'code': number;
    'message'?: string;
    'api_keys': Array<ApiKey>;
}
export interface AccountLimits {
    'code': number;
    'message'?: string;
    'max_llp_percentage': number;
    'user_tier': string;
}
export interface AccountMarginStats {
    'collateral': string;
    'portfolio_value': string;
    'leverage': string;
    'available_balance': string;
    'margin_usage': string;
    'buying_power': string;
}
export interface AccountMarketStats {
    'market_id': number;
    'daily_trades_count': number;
    'daily_base_token_volume': number;
    'daily_quote_token_volume': number;
    'weekly_trades_count': number;
    'weekly_base_token_volume': number;
    'weekly_quote_token_volume': number;
    'monthly_trades_count': number;
    'monthly_base_token_volume': number;
    'monthly_quote_token_volume': number;
    'total_trades_count': number;
    'total_base_token_volume': number;
    'total_quote_token_volume': number;
}
export interface AccountMetadata {
    'account_index': number;
    'name': string;
    'description': string;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'can_invite': boolean;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'referral_points_percentage': string;
}
export interface AccountMetadatas {
    'code': number;
    'message'?: string;
    'account_metadatas': Array<AccountMetadata>;
}
export interface AccountPnL {
    'code': number;
    'message'?: string;
    'resolution': string;
    'pnl': Array<PnLEntry>;
}
export interface AccountPosition {
    'market_id': number;
    'symbol': string;
    'initial_margin_fraction': string;
    'open_order_count': number;
    'pending_order_count': number;
    'position_tied_order_count': number;
    'sign': number;
    'position': string;
    'avg_entry_price': string;
    'position_value': string;
    'unrealized_pnl': string;
    'realized_pnl': string;
    'liquidation_price': string;
    'total_funding_paid_out'?: string;
    'margin_mode': number;
    'allocated_margin': string;
}
export interface AccountStats {
    'collateral': string;
    'portfolio_value': string;
    'leverage': string;
    'available_balance': string;
    'margin_usage': string;
    'buying_power': string;
    'cross_stats': AccountMarginStats;
    'total_stats': AccountMarginStats;
}
export interface AccountTradeStats {
    'daily_trades_count': number;
    'daily_volume': number;
    'weekly_trades_count': number;
    'weekly_volume': number;
    'monthly_trades_count': number;
    'monthly_volume': number;
    'total_trades_count': number;
    'total_volume': number;
}
export interface Announcement {
    'title': string;
    'content': string;
    'created_at': number;
}
export interface Announcements {
    'code': number;
    'message'?: string;
    'announcements': Array<Announcement>;
}
export interface ApiKey {
    'account_index': number;
    'api_key_index': number;
    'nonce': number;
    'public_key': string;
}
export interface Block {
    'commitment': string;
    'height': number;
    'state_root': string;
    'priority_operations': number;
    'on_chain_l2_operations': number;
    'pending_on_chain_operations_pub_data': string;
    'committed_tx_hash': string;
    'committed_at': number;
    'verified_tx_hash': string;
    'verified_at': number;
    'txs': Array<Tx>;
    'status': number;
    'size': number;
}
export interface Blocks {
    'code': number;
    'message'?: string;
    'total': number;
    'blocks': Array<Block>;
}
export interface BridgeSupportedNetwork {
    'name': string;
    'chain_id': string;
    'explorer': string;
}
export interface Candlestick {
    'timestamp': number;
    'open': number;
    'high': number;
    'low': number;
    'close': number;
    'volume0': number;
    'volume1': number;
    'last_trade_id': number;
}
export interface Candlesticks {
    'code': number;
    'message'?: string;
    'resolution': string;
    'candlesticks': Array<Candlestick>;
}
export interface ContractAddress {
    'name': string;
    'address': string;
}
export interface CurrentHeight {
    'code': number;
    'message'?: string;
    'height': number;
}
export interface Cursor {
    'next_cursor'?: string;
}
export interface DailyReturn {
    'timestamp': number;
    'daily_return': number;
}
export interface DepositHistory {
    'code': number;
    'message'?: string;
    'deposits': Array<DepositHistoryItem>;
    'cursor': string;
}
export interface DepositHistoryItem {
    'id': string;
    'amount': string;
    'timestamp': number;
    'status': DepositHistoryItemStatusEnum;
    'l1_tx_hash': string;
}

export const DepositHistoryItemStatusEnum = {
    Failed: 'failed',
    Pending: 'pending',
    Completed: 'completed',
    Claimable: 'claimable'
} as const;

export type DepositHistoryItemStatusEnum = typeof DepositHistoryItemStatusEnum[keyof typeof DepositHistoryItemStatusEnum];

export interface DetailedAccount {
    'code': number;
    'message'?: string;
    'account_type': number;
    'index': number;
    'l1_address': string;
    'cancel_all_time': number;
    'total_order_count': number;
    'total_isolated_order_count': number;
    'pending_order_count': number;
    'available_balance': string;
    'status': number;
    'collateral': string;
    'account_index': number;
    'name': string;
    'description': string;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'can_invite': boolean;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'referral_points_percentage': string;
    'positions': Array<AccountPosition>;
    'total_asset_value': string;
    'cross_asset_value': string;
    'pool_info': PublicPoolInfo;
    'shares': Array<PublicPoolShare>;
}
export interface DetailedAccounts {
    'code': number;
    'message'?: string;
    'total': number;
    'accounts': Array<DetailedAccount>;
}
export interface DetailedCandlestick {
    'timestamp': number;
    'open': number;
    'high': number;
    'low': number;
    'close': number;
    'volume0': number;
    'volume1': number;
    'last_trade_id': number;
    'trade_count': number;
}
export interface EnrichedTx {
    'code': number;
    'message'?: string;
    'hash': string;
    'type': number;
    'info': string;
    'event_info': string;
    'status': number;
    'transaction_index': number;
    'l1_address': string;
    'account_index': number;
    'nonce': number;
    'expire_at': number;
    'block_height': number;
    'queued_at': number;
    'executed_at': number;
    'sequence_index': number;
    'parent_hash': string;
    'committed_at': number;
    'verified_at': number;
}
export interface ExchangeStats {
    'code': number;
    'message'?: string;
    'total': number;
    'order_book_stats': Array<OrderBookStats>;
    'daily_usd_volume': number;
    'daily_trades_count': number;
}
export interface ExportData {
    'code': number;
    'message'?: string;
    'data_url': string;
}
export interface Funding {
    'timestamp': number;
    'value': string;
    'rate': string;
    'direction': string;
}
export interface FundingRate {
    'market_id': number;
    'exchange': FundingRateExchangeEnum;
    'symbol': string;
    'rate': number;
}

export const FundingRateExchangeEnum = {
    Binance: 'binance',
    Bybit: 'bybit',
    Hyperliquid: 'hyperliquid',
    Lighter: 'lighter'
} as const;

export type FundingRateExchangeEnum = typeof FundingRateExchangeEnum[keyof typeof FundingRateExchangeEnum];

export interface FundingRates {
    'code': number;
    'message'?: string;
    'funding_rates': Array<FundingRate>;
}
export interface Fundings {
    'code': number;
    'message'?: string;
    'resolution': string;
    'fundings': Array<Funding>;
}
export interface L1Metadata {
    'l1_address': string;
    'can_invite': boolean;
    'referral_points_percentage': string;
}
export interface L1ProviderInfo {
    'chainId': number;
    'networkId': number;
    'latestBlockNumber': number;
}
export interface LiqTrade {
    'price': string;
    'size': string;
    'taker_fee': string;
    'maker_fee': string;
}
export interface Liquidation {
    'id': number;
    'market_id': number;
    'type': LiquidationTypeEnum;
    'trade': LiqTrade;
    'info': LiquidationInfo;
    'executed_at': number;
}

export const LiquidationTypeEnum = {
    Partial: 'partial',
    Deleverage: 'deleverage'
} as const;

export type LiquidationTypeEnum = typeof LiquidationTypeEnum[keyof typeof LiquidationTypeEnum];

export interface LiquidationInfo {
    'positions': Array<AccountPosition>;
    'risk_info_before': RiskInfo;
    'risk_info_after': RiskInfo;
    'mark_prices': { [key: string]: number; };
}
export interface LiquidationInfos {
    'code': number;
    'message'?: string;
    'liquidations': Array<Liquidation>;
    'next_cursor'?: string;
}
export interface MarketInfo {
    'market_id': number;
    'index_price': string;
    'mark_price': string;
    'open_interest': string;
    'last_trade_price': string;
    'current_funding_rate': string;
    'funding_rate': string;
    'funding_timestamp': number;
    'daily_base_token_volume': number;
    'daily_quote_token_volume': number;
    'daily_price_low': number;
    'daily_price_high': number;
    'daily_price_change': number;
}
export interface NextNonce {
    'code': number;
    'message'?: string;
    'nonce': number;
}
export interface Order {
    'order_index': number;
    'client_order_index': number;
    'order_id': string;
    'client_order_id': string;
    'market_index': number;
    'owner_account_index': number;
    'initial_base_amount': string;
    'price': string;
    'nonce': number;
    'remaining_base_amount': string;
    'is_ask': boolean;
    'base_size': number;
    'base_price': number;
    'filled_base_amount': string;
    'filled_quote_amount': string;
    /**
     *  TODO: remove this
     */
    'side': string;
    'type': OrderTypeEnum;
    'time_in_force': OrderTimeInForceEnum;
    'reduce_only': boolean;
    'trigger_price': string;
    'order_expiry': number;
    'status': OrderStatusEnum;
    'trigger_status': OrderTriggerStatusEnum;
    'trigger_time': number;
    'parent_order_index': number;
    'parent_order_id': string;
    'to_trigger_order_id_0': string;
    'to_trigger_order_id_1': string;
    'to_cancel_order_id_0': string;
    'block_height': number;
    'timestamp': number;
}

export const OrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    StopLoss: 'stop-loss',
    StopLossLimit: 'stop-loss-limit',
    TakeProfit: 'take-profit',
    TakeProfitLimit: 'take-profit-limit',
    Twap: 'twap',
    TwapSub: 'twap-sub',
    Liquidation: 'liquidation'
} as const;

export type OrderTypeEnum = typeof OrderTypeEnum[keyof typeof OrderTypeEnum];
export const OrderTimeInForceEnum = {
    GoodTillTime: 'good-till-time',
    ImmediateOrCancel: 'immediate-or-cancel',
    PostOnly: 'post-only',
    Unknown: 'Unknown'
} as const;

export type OrderTimeInForceEnum = typeof OrderTimeInForceEnum[keyof typeof OrderTimeInForceEnum];
export const OrderStatusEnum = {
    InProgress: 'in-progress',
    Pending: 'pending',
    Open: 'open',
    Filled: 'filled',
    Canceled: 'canceled',
    CanceledPostOnly: 'canceled-post-only',
    CanceledReduceOnly: 'canceled-reduce-only',
    CanceledPositionNotAllowed: 'canceled-position-not-allowed',
    CanceledMarginNotAllowed: 'canceled-margin-not-allowed',
    CanceledTooMuchSlippage: 'canceled-too-much-slippage',
    CanceledNotEnoughLiquidity: 'canceled-not-enough-liquidity',
    CanceledSelfTrade: 'canceled-self-trade',
    CanceledExpired: 'canceled-expired',
    CanceledOco: 'canceled-oco',
    CanceledChild: 'canceled-child',
    CanceledLiquidation: 'canceled-liquidation'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];
export const OrderTriggerStatusEnum = {
    Na: 'na',
    Ready: 'ready',
    MarkPrice: 'mark-price',
    Twap: 'twap',
    ParentOrder: 'parent-order'
} as const;

export type OrderTriggerStatusEnum = typeof OrderTriggerStatusEnum[keyof typeof OrderTriggerStatusEnum];

export interface OrderBook {
    'symbol': string;
    'market_id': number;
    'status': OrderBookStatusEnum;
    'taker_fee': string;
    'maker_fee': string;
    'liquidation_fee': string;
    'min_base_amount': string;
    'min_quote_amount': string;
    'supported_size_decimals': number;
    'supported_price_decimals': number;
    'supported_quote_decimals': number;
}

export const OrderBookStatusEnum = {
    Inactive: 'inactive',
    Frozen: 'frozen',
    Active: 'active'
} as const;

export type OrderBookStatusEnum = typeof OrderBookStatusEnum[keyof typeof OrderBookStatusEnum];

export interface OrderBookDepth {
    'code': number;
    'message'?: string;
    'asks': Array<PriceLevel>;
    'bids': Array<PriceLevel>;
    'offset': number;
}
export interface OrderBookDetail {
    'symbol': string;
    'market_id': number;
    'status': OrderBookDetailStatusEnum;
    'taker_fee': string;
    'maker_fee': string;
    'liquidation_fee': string;
    'min_base_amount': string;
    'min_quote_amount': string;
    'supported_size_decimals': number;
    'supported_price_decimals': number;
    'supported_quote_decimals': number;
    'size_decimals': number;
    'price_decimals': number;
    'quote_multiplier': number;
    'default_initial_margin_fraction': number;
    'min_initial_margin_fraction': number;
    'maintenance_margin_fraction': number;
    'closeout_margin_fraction': number;
    'last_trade_price': number;
    'daily_trades_count': number;
    'daily_base_token_volume': number;
    'daily_quote_token_volume': number;
    'daily_price_low': number;
    'daily_price_high': number;
    'daily_price_change': number;
    'open_interest': number;
    'daily_chart': { [key: string]: number; };
}

export const OrderBookDetailStatusEnum = {
    Inactive: 'inactive',
    Frozen: 'frozen',
    Active: 'active'
} as const;

export type OrderBookDetailStatusEnum = typeof OrderBookDetailStatusEnum[keyof typeof OrderBookDetailStatusEnum];

export interface OrderBookDetails {
    'code': number;
    'message'?: string;
    'order_book_details': Array<OrderBookDetail>;
}
export interface OrderBookOrders {
    'code': number;
    'message'?: string;
    'total_asks': number;
    'asks': Array<SimpleOrder>;
    'total_bids': number;
    'bids': Array<SimpleOrder>;
}
export interface OrderBookStats {
    'symbol': string;
    'last_trade_price': number;
    'daily_trades_count': number;
    'daily_base_token_volume': number;
    'daily_quote_token_volume': number;
    'daily_price_change': number;
}
export interface OrderBooks {
    'code': number;
    'message'?: string;
    'order_books': Array<OrderBook>;
}
export interface Orders {
    'code': number;
    'message'?: string;
    'next_cursor'?: string;
    'orders': Array<Order>;
}
export interface PnLEntry {
    'timestamp': number;
    'trade_pnl': number;
    'inflow': number;
    'outflow': number;
    'pool_pnl': number;
    'pool_inflow': number;
    'pool_outflow': number;
    'pool_total_shares': number;
}
export interface PositionFunding {
    'timestamp': number;
    'market_id': number;
    'funding_id': number;
    'change': string;
    'rate': string;
    'position_size': string;
    'position_side': PositionFundingPositionSideEnum;
}

export const PositionFundingPositionSideEnum = {
    Long: 'long',
    Short: 'short'
} as const;

export type PositionFundingPositionSideEnum = typeof PositionFundingPositionSideEnum[keyof typeof PositionFundingPositionSideEnum];

export interface PositionFundings {
    'code': number;
    'message'?: string;
    'position_fundings': Array<PositionFunding>;
    'next_cursor'?: string;
}
export interface PriceLevel {
    'price': string;
    'size': string;
}
export interface PublicPool {
    'code': number;
    'message'?: string;
    'account_type': number;
    'index': number;
    'l1_address': string;
    'cancel_all_time': number;
    'total_order_count': number;
    'total_isolated_order_count': number;
    'pending_order_count': number;
    'available_balance': string;
    'status': number;
    'collateral': string;
    'account_index': number;
    'name': string;
    'description': string;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'can_invite': boolean;
    /**
     *  Remove After FE uses L1 meta endpoint
     */
    'referral_points_percentage': string;
    'total_asset_value': string;
    'cross_asset_value': string;
    'pool_info': PublicPoolInfo;
    'account_share'?: PublicPoolShare;
}
export interface PublicPoolInfo {
    'status': number;
    'operator_fee': string;
    'min_operator_share_rate': string;
    'total_shares': number;
    'operator_shares': number;
    'annual_percentage_yield': number;
    'daily_returns': Array<DailyReturn>;
    'share_prices': Array<SharePrice>;
}
export interface PublicPoolMetadata {
    'code': number;
    'message'?: string;
    'account_index': number;
    'account_type': number;
    'name': string;
    'l1_address': string;
    'annual_percentage_yield': number;
    'status': number;
    'operator_fee': string;
    'total_asset_value': string;
    'total_shares': number;
    'account_share'?: PublicPoolShare;
}
export interface PublicPoolShare {
    'public_pool_index': number;
    'shares_amount': number;
    'entry_usdc': string;
}
export interface PublicPools {
    'code': number;
    'message'?: string;
    'total': number;
    'public_pools': Array<PublicPool>;
}
export interface ReferralPointEntry {
    'l1_address': string;
    'total_points': number;
    'week_points': number;
    'total_reward_points': number;
    'week_reward_points': number;
    'reward_point_multiplier': string;
}
export interface ReferralPoints {
    'referrals': Array<ReferralPointEntry>;
    'user_total_points': number;
    'user_last_week_points': number;
    'user_total_referral_reward_points': number;
    'user_last_week_referral_reward_points': number;
    'reward_point_multiplier': string;
}
export interface ReqExportData {
    'auth'?: string;
    'account_index'?: number;
    'market_id'?: number;
    'type': ReqExportDataTypeEnum;
}

export const ReqExportDataTypeEnum = {
    Funding: 'funding',
    Trade: 'trade'
} as const;

export type ReqExportDataTypeEnum = typeof ReqExportDataTypeEnum[keyof typeof ReqExportDataTypeEnum];

export interface ReqGetAccount {
    'by': ReqGetAccountByEnum;
    'value': string;
}

export const ReqGetAccountByEnum = {
    Index: 'index',
    L1Address: 'l1_address'
} as const;

export type ReqGetAccountByEnum = typeof ReqGetAccountByEnum[keyof typeof ReqGetAccountByEnum];

export interface ReqGetAccountActiveOrders {
    'account_index': number;
    'market_id': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
}
export interface ReqGetAccountApiKeys {
    'account_index': number;
    'api_key_index'?: number;
}
export interface ReqGetAccountByL1Address {
    'l1_address': string;
}
export interface ReqGetAccountInactiveOrders {
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'account_index': number;
    'market_id'?: number;
    'ask_filter'?: number;
    'between_timestamps'?: string;
    'cursor'?: string;
    'limit': number;
}
export interface ReqGetAccountLimits {
    'account_index': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
}
export interface ReqGetAccountMetadata {
    'by': ReqGetAccountMetadataByEnum;
    'value': string;
    'auth'?: string;
}

export const ReqGetAccountMetadataByEnum = {
    Index: 'index',
    L1Address: 'l1_address'
} as const;

export type ReqGetAccountMetadataByEnum = typeof ReqGetAccountMetadataByEnum[keyof typeof ReqGetAccountMetadataByEnum];

export interface ReqGetAccountPnL {
    'auth'?: string;
    'by': ReqGetAccountPnLByEnum;
    'value': string;
    'resolution': ReqGetAccountPnLResolutionEnum;
    'start_timestamp': number;
    'end_timestamp': number;
    'count_back': number;
    'ignore_transfers'?: boolean;
}

export const ReqGetAccountPnLByEnum = {
    Index: 'index'
} as const;

export type ReqGetAccountPnLByEnum = typeof ReqGetAccountPnLByEnum[keyof typeof ReqGetAccountPnLByEnum];
export const ReqGetAccountPnLResolutionEnum = {
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _1h: '1h',
    _4h: '4h',
    _1d: '1d'
} as const;

export type ReqGetAccountPnLResolutionEnum = typeof ReqGetAccountPnLResolutionEnum[keyof typeof ReqGetAccountPnLResolutionEnum];

export interface ReqGetAccountTxs {
    'index'?: number;
    'limit'?: number;
    'by'?: ReqGetAccountTxsByEnum;
    'value'?: string;
    'types'?: Array<number>;
    'auth'?: string;
}

export const ReqGetAccountTxsByEnum = {
    AccountIndex: 'account_index'
} as const;

export type ReqGetAccountTxsByEnum = typeof ReqGetAccountTxsByEnum[keyof typeof ReqGetAccountTxsByEnum];

export interface ReqGetBlock {
    'by': ReqGetBlockByEnum;
    'value': string;
}

export const ReqGetBlockByEnum = {
    Commitment: 'commitment',
    Height: 'height'
} as const;

export type ReqGetBlockByEnum = typeof ReqGetBlockByEnum[keyof typeof ReqGetBlockByEnum];

export interface ReqGetBlockTxs {
    'by': ReqGetBlockTxsByEnum;
    'value': string;
}

export const ReqGetBlockTxsByEnum = {
    BlockHeight: 'block_height',
    BlockCommitment: 'block_commitment'
} as const;

export type ReqGetBlockTxsByEnum = typeof ReqGetBlockTxsByEnum[keyof typeof ReqGetBlockTxsByEnum];

export interface ReqGetByAccount {
    'by': ReqGetByAccountByEnum;
    'value': string;
}

export const ReqGetByAccountByEnum = {
    AccountIndex: 'account_index'
} as const;

export type ReqGetByAccountByEnum = typeof ReqGetByAccountByEnum[keyof typeof ReqGetByAccountByEnum];

export interface ReqGetCandlesticks {
    'market_id': number;
    'resolution': ReqGetCandlesticksResolutionEnum;
    'start_timestamp': number;
    'end_timestamp': number;
    'count_back': number;
    'set_timestamp_to_end'?: boolean;
}

export const ReqGetCandlesticksResolutionEnum = {
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _1h: '1h',
    _4h: '4h',
    _1d: '1d'
} as const;

export type ReqGetCandlesticksResolutionEnum = typeof ReqGetCandlesticksResolutionEnum[keyof typeof ReqGetCandlesticksResolutionEnum];

export interface ReqGetDepositHistory {
    'account_index': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'l1_address': string;
    'cursor'?: string;
    'filter'?: ReqGetDepositHistoryFilterEnum;
}

export const ReqGetDepositHistoryFilterEnum = {
    All: 'all',
    Pending: 'pending',
    Claimable: 'claimable'
} as const;

export type ReqGetDepositHistoryFilterEnum = typeof ReqGetDepositHistoryFilterEnum[keyof typeof ReqGetDepositHistoryFilterEnum];

export interface ReqGetFastWithdrawInfo {
    'account_index': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
}
export interface ReqGetFundings {
    'market_id': number;
    'resolution': ReqGetFundingsResolutionEnum;
    'start_timestamp': number;
    'end_timestamp': number;
    'count_back': number;
}

export const ReqGetFundingsResolutionEnum = {
    _1h: '1h',
    _1d: '1d'
} as const;

export type ReqGetFundingsResolutionEnum = typeof ReqGetFundingsResolutionEnum[keyof typeof ReqGetFundingsResolutionEnum];

export interface ReqGetL1Metadata {
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'l1_address': string;
}
export interface ReqGetL1Tx {
    'hash': string;
}
export interface ReqGetLatestDeposit {
    'l1_address': string;
}
export interface ReqGetLiquidationInfos {
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'account_index': number;
    'market_id'?: number;
    'cursor'?: string;
    'limit': number;
}
export interface ReqGetNextNonce {
    'account_index': number;
    'api_key_index': number;
}
export interface ReqGetOrderBookDetails {
    'market_id'?: number;
}
export interface ReqGetOrderBookOrders {
    'market_id': number;
    'limit': number;
}
export interface ReqGetOrderBooks {
    'market_id'?: number;
}
export interface ReqGetPositionFunding {
    'auth'?: string;
    'account_index': number;
    'market_id'?: number;
    'cursor'?: string;
    'limit': number;
    'side'?: ReqGetPositionFundingSideEnum;
}

export const ReqGetPositionFundingSideEnum = {
    Long: 'long',
    Short: 'short',
    All: 'all'
} as const;

export type ReqGetPositionFundingSideEnum = typeof ReqGetPositionFundingSideEnum[keyof typeof ReqGetPositionFundingSideEnum];

export interface ReqGetPublicPools {
    'auth'?: string;
    'filter'?: ReqGetPublicPoolsFilterEnum;
    'index': number;
    'limit': number;
    'account_index'?: number;
}

export const ReqGetPublicPoolsFilterEnum = {
    All: 'all',
    User: 'user',
    Protocol: 'protocol',
    AccountIndex: 'account_index'
} as const;

export type ReqGetPublicPoolsFilterEnum = typeof ReqGetPublicPoolsFilterEnum[keyof typeof ReqGetPublicPoolsFilterEnum];

export interface ReqGetPublicPoolsMetadata {
    'auth'?: string;
    'filter'?: ReqGetPublicPoolsMetadataFilterEnum;
    'index': number;
    'limit': number;
    'account_index'?: number;
}

export const ReqGetPublicPoolsMetadataFilterEnum = {
    All: 'all',
    User: 'user',
    Protocol: 'protocol',
    AccountIndex: 'account_index'
} as const;

export type ReqGetPublicPoolsMetadataFilterEnum = typeof ReqGetPublicPoolsMetadataFilterEnum[keyof typeof ReqGetPublicPoolsMetadataFilterEnum];

export interface ReqGetRangeWithCursor {
    'cursor'?: string;
    'limit': number;
}
export interface ReqGetRangeWithIndex {
    'index'?: number;
    'limit': number;
}
export interface ReqGetRangeWithIndexSortable {
    'index'?: number;
    'limit'?: number;
    'sort'?: ReqGetRangeWithIndexSortableSortEnum;
}

export const ReqGetRangeWithIndexSortableSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ReqGetRangeWithIndexSortableSortEnum = typeof ReqGetRangeWithIndexSortableSortEnum[keyof typeof ReqGetRangeWithIndexSortableSortEnum];

export interface ReqGetRecentTrades {
    'market_id': number;
    'limit': number;
}
export interface ReqGetReferralPoints {
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'account_index': number;
}
export interface ReqGetTrades {
    'auth'?: string;
    'market_id'?: number;
    'account_index'?: number;
    'order_index'?: number;
    'sort_by': ReqGetTradesSortByEnum;
    'sort_dir'?: ReqGetTradesSortDirEnum;
    'cursor'?: string;
    'from'?: number;
    'ask_filter'?: number;
    'limit': number;
}

export const ReqGetTradesSortByEnum = {
    BlockHeight: 'block_height',
    Timestamp: 'timestamp',
    TradeId: 'trade_id'
} as const;

export type ReqGetTradesSortByEnum = typeof ReqGetTradesSortByEnum[keyof typeof ReqGetTradesSortByEnum];
export const ReqGetTradesSortDirEnum = {
    Desc: 'desc'
} as const;

export type ReqGetTradesSortDirEnum = typeof ReqGetTradesSortDirEnum[keyof typeof ReqGetTradesSortDirEnum];

export interface ReqGetTransferFeeInfo {
    'auth'?: string;
    'account_index': number;
    'to_account_index'?: number;
}
export interface ReqGetTransferHistory {
    'account_index': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'cursor'?: string;
}
export interface ReqGetTx {
    'by': ReqGetTxByEnum;
    'value': string;
}

export const ReqGetTxByEnum = {
    Hash: 'hash',
    SequenceIndex: 'sequence_index'
} as const;

export type ReqGetTxByEnum = typeof ReqGetTxByEnum[keyof typeof ReqGetTxByEnum];

export interface ReqGetWithdrawHistory {
    'account_index': number;
    /**
     *  made optional to support header auth clients
     */
    'auth'?: string;
    'cursor'?: string;
    'filter'?: ReqGetWithdrawHistoryFilterEnum;
}

export const ReqGetWithdrawHistoryFilterEnum = {
    All: 'all',
    Pending: 'pending',
    Claimable: 'claimable'
} as const;

export type ReqGetWithdrawHistoryFilterEnum = typeof ReqGetWithdrawHistoryFilterEnum[keyof typeof ReqGetWithdrawHistoryFilterEnum];

export interface RespChangeAccountTier {
    'code': number;
    'message'?: string;
}
export interface RespGetFastBridgeInfo {
    'code': number;
    'message'?: string;
    'fast_bridge_limit': string;
}
export interface RespPublicPoolsMetadata {
    'code': number;
    'message'?: string;
    'public_pools': Array<PublicPoolMetadata>;
}
export interface RespSendTx {
    'code': number;
    'message'?: string;
    'tx_hash': string;
    'predicted_execution_time_ms': number;
}
export interface RespSendTxBatch {
    'code': number;
    'message'?: string;
    'tx_hash': Array<string>;
    'predicted_execution_time_ms': number;
}
export interface RespWithdrawalDelay {
    'seconds': number;
}
export interface ResultCode {
    'code': number;
    'message'?: string;
}
export interface RiskInfo {
    'cross_risk_parameters': RiskParameters;
    'isolated_risk_parameters': Array<RiskParameters>;
}
export interface RiskParameters {
    'market_id': number;
    'collateral': string;
    'total_account_value': string;
    'initial_margin_req': string;
    'maintenance_margin_req': string;
    'close_out_margin_req': string;
}
export interface SharePrice {
    'timestamp': number;
    'share_price': number;
}
export interface SimpleOrder {
    'order_index': number;
    'order_id': string;
    'owner_account_index': number;
    'initial_base_amount': string;
    'remaining_base_amount': string;
    'price': string;
    'order_expiry': number;
}
export interface Status {
    'status': number;
    'network_id': number;
    'timestamp': number;
}
export interface SubAccounts {
    'code': number;
    'message'?: string;
    'l1_address': string;
    'sub_accounts': Array<Account>;
}
export interface Ticker {
    's': string;
    'a': PriceLevel;
    'b': PriceLevel;
}
export interface Trade {
    'trade_id': number;
    'tx_hash': string;
    'type': TradeTypeEnum;
    'market_id': number;
    'size': string;
    'price': string;
    'usd_amount': string;
    'ask_id': number;
    'bid_id': number;
    'ask_account_id': number;
    'bid_account_id': number;
    'is_maker_ask': boolean;
    'block_height': number;
    'timestamp': number;
    'taker_fee': number;
    'taker_position_size_before': string;
    'taker_entry_quote_before': string;
    'taker_initial_margin_fraction_before': number;
    'taker_position_sign_changed': boolean;
    'maker_fee': number;
    'maker_position_size_before': string;
    'maker_entry_quote_before': string;
    'maker_initial_margin_fraction_before': number;
    'maker_position_sign_changed': boolean;
}

export const TradeTypeEnum = {
    Trade: 'trade',
    Liquidation: 'liquidation',
    Deleverage: 'deleverage'
} as const;

export type TradeTypeEnum = typeof TradeTypeEnum[keyof typeof TradeTypeEnum];

export interface Trades {
    'code': number;
    'message'?: string;
    'next_cursor'?: string;
    'trades': Array<Trade>;
}
export interface TransferFeeInfo {
    'code': number;
    'message'?: string;
    'transfer_fee_usdc': number;
}
export interface TransferHistory {
    'code': number;
    'message'?: string;
    'transfers': Array<TransferHistoryItem>;
    'cursor': string;
}
export interface TransferHistoryItem {
    'id': string;
    'amount': string;
    'timestamp': number;
    'type': TransferHistoryItemTypeEnum;
    'from_l1_address': string;
    'to_l1_address': string;
    'from_account_index': number;
    'to_account_index': number;
    'tx_hash': string;
}

export const TransferHistoryItemTypeEnum = {
    L2TransferInflow: 'L2TransferInflow',
    L2TransferOutflow: 'L2TransferOutflow'
} as const;

export type TransferHistoryItemTypeEnum = typeof TransferHistoryItemTypeEnum[keyof typeof TransferHistoryItemTypeEnum];

export interface Tx {
    'hash': string;
    'type': number;
    'info': string;
    'event_info': string;
    'status': number;
    'transaction_index': number;
    'l1_address': string;
    'account_index': number;
    'nonce': number;
    'expire_at': number;
    'block_height': number;
    'queued_at': number;
    'executed_at': number;
    'sequence_index': number;
    'parent_hash': string;
}
export interface TxHash {
    'code': number;
    'message'?: string;
    'tx_hash': string;
}
export interface TxHashes {
    'code': number;
    'message'?: string;
    'tx_hash': Array<string>;
}
export interface Txs {
    'code': number;
    'message'?: string;
    'txs': Array<Tx>;
}
export interface ValidatorInfo {
    'address': string;
    'is_active': boolean;
}
export interface WithdrawHistory {
    'code': number;
    'message'?: string;
    'withdraws': Array<WithdrawHistoryItem>;
    'cursor': string;
}
export interface WithdrawHistoryItem {
    'id': string;
    'amount': string;
    'timestamp': number;
    'status': WithdrawHistoryItemStatusEnum;
    'type': WithdrawHistoryItemTypeEnum;
    'l1_tx_hash': string;
}

export const WithdrawHistoryItemStatusEnum = {
    Failed: 'failed',
    Pending: 'pending',
    Claimable: 'claimable',
    Refunded: 'refunded',
    Completed: 'completed'
} as const;

export type WithdrawHistoryItemStatusEnum = typeof WithdrawHistoryItemStatusEnum[keyof typeof WithdrawHistoryItemStatusEnum];
export const WithdrawHistoryItemTypeEnum = {
    Secure: 'secure',
    Fast: 'fast'
} as const;

export type WithdrawHistoryItemTypeEnum = typeof WithdrawHistoryItemTypeEnum[keyof typeof WithdrawHistoryItemTypeEnum];

export interface ZkLighterInfo {
    'contract_address': string;
}

/**
 * AccountApi - axios parameter creator
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get account by account\'s index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.
         * @summary account
         * @param {AccountByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: async (by: AccountByEnum, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('account', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('account', 'value', value)
            const localVarPath = `/api/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account limits
         * @summary accountLimits
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLimits: async (accountIndex: number, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('accountLimits', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/accountLimits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account metadatas
         * @summary accountMetadata
         * @param {AccountMetadataByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountMetadata: async (by: AccountMetadataByEnum, value: string, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('accountMetadata', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('accountMetadata', 'value', value)
            const localVarPath = `/api/v1/accountMetadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get accounts by l1_address returns all accounts associated with the given L1 address
         * @summary accountsByL1Address
         * @param {string} l1Address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsByL1Address: async (l1Address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'l1Address' is not null or undefined
            assertParamExists('accountsByL1Address', 'l1Address', l1Address)
            const localVarPath = `/api/v1/accountsByL1Address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (l1Address !== undefined) {
                localVarQueryParameter['l1_address'] = l1Address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.
         * @summary apikeys
         * @param {number} accountIndex 
         * @param {number} [apiKeyIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeys: async (accountIndex: number, apiKeyIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('apikeys', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (apiKeyIndex !== undefined) {
                localVarQueryParameter['api_key_index'] = apiKeyIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change account tier
         * @summary changeAccountTier
         * @param {number} accountIndex 
         * @param {string} newTier 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountTier: async (accountIndex: number, newTier: string, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('changeAccountTier', 'accountIndex', accountIndex)
            // verify required parameter 'newTier' is not null or undefined
            assertParamExists('changeAccountTier', 'newTier', newTier)
            const localVarPath = `/api/v1/changeAccountTier`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (auth !== undefined) { 
                localVarFormParams.append('auth', auth as any);
            }
    
            if (accountIndex !== undefined) { 
                localVarFormParams.append('account_index', accountIndex as any);
            }
    
            if (newTier !== undefined) { 
                localVarFormParams.append('new_tier', newTier as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get L1 metadata
         * @summary l1Metadata
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        l1Metadata: async (l1Address: string, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'l1Address' is not null or undefined
            assertParamExists('l1Metadata', 'l1Address', l1Address)
            const localVarPath = `/api/v1/l1Metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (l1Address !== undefined) {
                localVarQueryParameter['l1_address'] = l1Address;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get liquidation infos
         * @summary liquidations
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidations: async (accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('liquidations', 'accountIndex', accountIndex)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('liquidations', 'limit', limit)
            const localVarPath = `/api/v1/liquidations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account PnL chart
         * @summary pnl
         * @param {PnlByEnum} by 
         * @param {string} value 
         * @param {PnlResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {boolean} [ignoreTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnl: async (by: PnlByEnum, value: string, resolution: PnlResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, authorization?: string, auth?: string, ignoreTransfers?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('pnl', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('pnl', 'value', value)
            // verify required parameter 'resolution' is not null or undefined
            assertParamExists('pnl', 'resolution', resolution)
            // verify required parameter 'startTimestamp' is not null or undefined
            assertParamExists('pnl', 'startTimestamp', startTimestamp)
            // verify required parameter 'endTimestamp' is not null or undefined
            assertParamExists('pnl', 'endTimestamp', endTimestamp)
            // verify required parameter 'countBack' is not null or undefined
            assertParamExists('pnl', 'countBack', countBack)
            const localVarPath = `/api/v1/pnl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }

            if (countBack !== undefined) {
                localVarQueryParameter['count_back'] = countBack;
            }

            if (ignoreTransfers !== undefined) {
                localVarQueryParameter['ignore_transfers'] = ignoreTransfers;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get accounts position fundings
         * @summary positionFunding
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {PositionFundingSideEnum} [side] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionFunding: async (accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, side?: PositionFundingSideEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('positionFunding', 'accountIndex', accountIndex)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('positionFunding', 'limit', limit)
            const localVarPath = `/api/v1/positionFunding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (side !== undefined) {
                localVarQueryParameter['side'] = side;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public pools
         * @summary publicPools
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPools: async (index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsFilterEnum, accountIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('publicPools', 'index', index)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('publicPools', 'limit', limit)
            const localVarPath = `/api/v1/publicPools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public pools metadata
         * @summary publicPoolsMetadata
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsMetadataFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPoolsMetadata: async (index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsMetadataFilterEnum, accountIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('publicPoolsMetadata', 'index', index)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('publicPoolsMetadata', 'limit', limit)
            const localVarPath = `/api/v1/publicPoolsMetadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get account by account\'s index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.
         * @summary account
         * @param {AccountByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async account(by: AccountByEnum, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedAccounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.account(by, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.account']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account limits
         * @summary accountLimits
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLimits(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountLimits(accountIndex, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account metadatas
         * @summary accountMetadata
         * @param {AccountMetadataByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountMetadata(by: AccountMetadataByEnum, value: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountMetadatas>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountMetadata(by, value, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get accounts by l1_address returns all accounts associated with the given L1 address
         * @summary accountsByL1Address
         * @param {string} l1Address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsByL1Address(l1Address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubAccounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsByL1Address(l1Address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.accountsByL1Address']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.
         * @summary apikeys
         * @param {number} accountIndex 
         * @param {number} [apiKeyIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apikeys(accountIndex: number, apiKeyIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountApiKeys>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apikeys(accountIndex, apiKeyIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.apikeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change account tier
         * @summary changeAccountTier
         * @param {number} accountIndex 
         * @param {string} newTier 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeAccountTier(accountIndex: number, newTier: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespChangeAccountTier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeAccountTier(accountIndex, newTier, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.changeAccountTier']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get L1 metadata
         * @summary l1Metadata
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async l1Metadata(l1Address: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<L1Metadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.l1Metadata(l1Address, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.l1Metadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get liquidation infos
         * @summary liquidations
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liquidations(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiquidationInfos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liquidations(accountIndex, limit, authorization, auth, marketId, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.liquidations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account PnL chart
         * @summary pnl
         * @param {PnlByEnum} by 
         * @param {string} value 
         * @param {PnlResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {boolean} [ignoreTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pnl(by: PnlByEnum, value: string, resolution: PnlResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, authorization?: string, auth?: string, ignoreTransfers?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPnL>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pnl(by, value, resolution, startTimestamp, endTimestamp, countBack, authorization, auth, ignoreTransfers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.pnl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get accounts position fundings
         * @summary positionFunding
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {PositionFundingSideEnum} [side] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async positionFunding(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, side?: PositionFundingSideEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionFundings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.positionFunding(accountIndex, limit, authorization, auth, marketId, cursor, side, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.positionFunding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public pools
         * @summary publicPools
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPools(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicPools>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicPools(index, limit, authorization, auth, filter, accountIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.publicPools']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public pools metadata
         * @summary publicPoolsMetadata
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsMetadataFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicPoolsMetadata(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsMetadataFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespPublicPoolsMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicPoolsMetadata(index, limit, authorization, auth, filter, accountIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.publicPoolsMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Get account by account\'s index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.
         * @summary account
         * @param {AccountByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account(by: AccountByEnum, value: string, options?: RawAxiosRequestConfig): AxiosPromise<DetailedAccounts> {
            return localVarFp.account(by, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account limits
         * @summary accountLimits
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLimits(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountLimits> {
            return localVarFp.accountLimits(accountIndex, authorization, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account metadatas
         * @summary accountMetadata
         * @param {AccountMetadataByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountMetadata(by: AccountMetadataByEnum, value: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountMetadatas> {
            return localVarFp.accountMetadata(by, value, authorization, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get accounts by l1_address returns all accounts associated with the given L1 address
         * @summary accountsByL1Address
         * @param {string} l1Address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsByL1Address(l1Address: string, options?: RawAxiosRequestConfig): AxiosPromise<SubAccounts> {
            return localVarFp.accountsByL1Address(l1Address, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.
         * @summary apikeys
         * @param {number} accountIndex 
         * @param {number} [apiKeyIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apikeys(accountIndex: number, apiKeyIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountApiKeys> {
            return localVarFp.apikeys(accountIndex, apiKeyIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Change account tier
         * @summary changeAccountTier
         * @param {number} accountIndex 
         * @param {string} newTier 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeAccountTier(accountIndex: number, newTier: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<RespChangeAccountTier> {
            return localVarFp.changeAccountTier(accountIndex, newTier, authorization, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get L1 metadata
         * @summary l1Metadata
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        l1Metadata(l1Address: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<L1Metadata> {
            return localVarFp.l1Metadata(l1Address, authorization, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get liquidation infos
         * @summary liquidations
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidations(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<LiquidationInfos> {
            return localVarFp.liquidations(accountIndex, limit, authorization, auth, marketId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account PnL chart
         * @summary pnl
         * @param {PnlByEnum} by 
         * @param {string} value 
         * @param {PnlResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {boolean} [ignoreTransfers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnl(by: PnlByEnum, value: string, resolution: PnlResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, authorization?: string, auth?: string, ignoreTransfers?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AccountPnL> {
            return localVarFp.pnl(by, value, resolution, startTimestamp, endTimestamp, countBack, authorization, auth, ignoreTransfers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get accounts position fundings
         * @summary positionFunding
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {string} [cursor] 
         * @param {PositionFundingSideEnum} [side] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        positionFunding(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, side?: PositionFundingSideEnum, options?: RawAxiosRequestConfig): AxiosPromise<PositionFundings> {
            return localVarFp.positionFunding(accountIndex, limit, authorization, auth, marketId, cursor, side, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public pools
         * @summary publicPools
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPools(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicPools> {
            return localVarFp.publicPools(index, limit, authorization, auth, filter, accountIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public pools metadata
         * @summary publicPoolsMetadata
         * @param {number} index 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {PublicPoolsMetadataFilterEnum} [filter] 
         * @param {number} [accountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicPoolsMetadata(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsMetadataFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<RespPublicPoolsMetadata> {
            return localVarFp.publicPoolsMetadata(index, limit, authorization, auth, filter, accountIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * Get account by account\'s index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.
     * @summary account
     * @param {AccountByEnum} by 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public account(by: AccountByEnum, value: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).account(by, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account limits
     * @summary accountLimits
     * @param {number} accountIndex 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountLimits(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountLimits(accountIndex, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account metadatas
     * @summary accountMetadata
     * @param {AccountMetadataByEnum} by 
     * @param {string} value 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountMetadata(by: AccountMetadataByEnum, value: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountMetadata(by, value, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get accounts by l1_address returns all accounts associated with the given L1 address
     * @summary accountsByL1Address
     * @param {string} l1Address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountsByL1Address(l1Address: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountsByL1Address(l1Address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.
     * @summary apikeys
     * @param {number} accountIndex 
     * @param {number} [apiKeyIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public apikeys(accountIndex: number, apiKeyIndex?: number, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).apikeys(accountIndex, apiKeyIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change account tier
     * @summary changeAccountTier
     * @param {number} accountIndex 
     * @param {string} newTier 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changeAccountTier(accountIndex: number, newTier: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).changeAccountTier(accountIndex, newTier, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get L1 metadata
     * @summary l1Metadata
     * @param {string} l1Address 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public l1Metadata(l1Address: string, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).l1Metadata(l1Address, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get liquidation infos
     * @summary liquidations
     * @param {number} accountIndex 
     * @param {number} limit 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {number} [marketId] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public liquidations(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).liquidations(accountIndex, limit, authorization, auth, marketId, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account PnL chart
     * @summary pnl
     * @param {PnlByEnum} by 
     * @param {string} value 
     * @param {PnlResolutionEnum} resolution 
     * @param {number} startTimestamp 
     * @param {number} endTimestamp 
     * @param {number} countBack 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {boolean} [ignoreTransfers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pnl(by: PnlByEnum, value: string, resolution: PnlResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, authorization?: string, auth?: string, ignoreTransfers?: boolean, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).pnl(by, value, resolution, startTimestamp, endTimestamp, countBack, authorization, auth, ignoreTransfers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get accounts position fundings
     * @summary positionFunding
     * @param {number} accountIndex 
     * @param {number} limit 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {number} [marketId] 
     * @param {string} [cursor] 
     * @param {PositionFundingSideEnum} [side] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public positionFunding(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, cursor?: string, side?: PositionFundingSideEnum, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).positionFunding(accountIndex, limit, authorization, auth, marketId, cursor, side, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public pools
     * @summary publicPools
     * @param {number} index 
     * @param {number} limit 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {PublicPoolsFilterEnum} [filter] 
     * @param {number} [accountIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public publicPools(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).publicPools(index, limit, authorization, auth, filter, accountIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public pools metadata
     * @summary publicPoolsMetadata
     * @param {number} index 
     * @param {number} limit 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {PublicPoolsMetadataFilterEnum} [filter] 
     * @param {number} [accountIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public publicPoolsMetadata(index: number, limit: number, authorization?: string, auth?: string, filter?: PublicPoolsMetadataFilterEnum, accountIndex?: number, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).publicPoolsMetadata(index, limit, authorization, auth, filter, accountIndex, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AccountByEnum = {
    Index: 'index',
    L1Address: 'l1_address'
} as const;
export type AccountByEnum = typeof AccountByEnum[keyof typeof AccountByEnum];
export const AccountMetadataByEnum = {
    Index: 'index',
    L1Address: 'l1_address'
} as const;
export type AccountMetadataByEnum = typeof AccountMetadataByEnum[keyof typeof AccountMetadataByEnum];
export const PnlByEnum = {
    Index: 'index'
} as const;
export type PnlByEnum = typeof PnlByEnum[keyof typeof PnlByEnum];
export const PnlResolutionEnum = {
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _1h: '1h',
    _4h: '4h',
    _1d: '1d'
} as const;
export type PnlResolutionEnum = typeof PnlResolutionEnum[keyof typeof PnlResolutionEnum];
export const PositionFundingSideEnum = {
    Long: 'long',
    Short: 'short',
    All: 'all'
} as const;
export type PositionFundingSideEnum = typeof PositionFundingSideEnum[keyof typeof PositionFundingSideEnum];
export const PublicPoolsFilterEnum = {
    All: 'all',
    User: 'user',
    Protocol: 'protocol',
    AccountIndex: 'account_index'
} as const;
export type PublicPoolsFilterEnum = typeof PublicPoolsFilterEnum[keyof typeof PublicPoolsFilterEnum];
export const PublicPoolsMetadataFilterEnum = {
    All: 'all',
    User: 'user',
    Protocol: 'protocol',
    AccountIndex: 'account_index'
} as const;
export type PublicPoolsMetadataFilterEnum = typeof PublicPoolsMetadataFilterEnum[keyof typeof PublicPoolsMetadataFilterEnum];


/**
 * AnnouncementApi - axios parameter creator
 */
export const AnnouncementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get announcement
         * @summary announcement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcement: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/announcement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnouncementApi - functional programming interface
 */
export const AnnouncementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnouncementApiAxiosParamCreator(configuration)
    return {
        /**
         * Get announcement
         * @summary announcement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcement(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Announcements>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcement(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnouncementApi.announcement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnouncementApi - factory interface
 */
export const AnnouncementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnouncementApiFp(configuration)
    return {
        /**
         * Get announcement
         * @summary announcement
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcement(options?: RawAxiosRequestConfig): AxiosPromise<Announcements> {
            return localVarFp.announcement(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnouncementApi - object-oriented interface
 */
export class AnnouncementApi extends BaseAPI {
    /**
     * Get announcement
     * @summary announcement
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public announcement(options?: RawAxiosRequestConfig) {
        return AnnouncementApiFp(this.configuration).announcement(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BlockApi - axios parameter creator
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get block by its height or commitment
         * @summary block
         * @param {BlockByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: async (by: BlockByEnum, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('block', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('block', 'value', value)
            const localVarPath = `/api/v1/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get blocks
         * @summary blocks
         * @param {number} limit 
         * @param {number} [index] 
         * @param {BlocksSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks: async (limit: number, index?: number, sort?: BlocksSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('blocks', 'limit', limit)
            const localVarPath = `/api/v1/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current height
         * @summary currentHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentHeight: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/currentHeight`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 */
export const BlockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockApiAxiosParamCreator(configuration)
    return {
        /**
         * Get block by its height or commitment
         * @summary block
         * @param {BlockByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async block(by: BlockByEnum, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blocks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.block(by, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockApi.block']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get blocks
         * @summary blocks
         * @param {number} limit 
         * @param {number} [index] 
         * @param {BlocksSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocks(limit: number, index?: number, sort?: BlocksSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blocks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blocks(limit, index, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockApi.blocks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current height
         * @summary currentHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentHeight(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentHeight>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentHeight(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockApi.currentHeight']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlockApi - factory interface
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockApiFp(configuration)
    return {
        /**
         * Get block by its height or commitment
         * @summary block
         * @param {BlockByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(by: BlockByEnum, value: string, options?: RawAxiosRequestConfig): AxiosPromise<Blocks> {
            return localVarFp.block(by, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get blocks
         * @summary blocks
         * @param {number} limit 
         * @param {number} [index] 
         * @param {BlocksSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocks(limit: number, index?: number, sort?: BlocksSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Blocks> {
            return localVarFp.blocks(limit, index, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current height
         * @summary currentHeight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentHeight(options?: RawAxiosRequestConfig): AxiosPromise<CurrentHeight> {
            return localVarFp.currentHeight(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 */
export class BlockApi extends BaseAPI {
    /**
     * Get block by its height or commitment
     * @summary block
     * @param {BlockByEnum} by 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public block(by: BlockByEnum, value: string, options?: RawAxiosRequestConfig) {
        return BlockApiFp(this.configuration).block(by, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get blocks
     * @summary blocks
     * @param {number} limit 
     * @param {number} [index] 
     * @param {BlocksSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public blocks(limit: number, index?: number, sort?: BlocksSortEnum, options?: RawAxiosRequestConfig) {
        return BlockApiFp(this.configuration).blocks(limit, index, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current height
     * @summary currentHeight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public currentHeight(options?: RawAxiosRequestConfig) {
        return BlockApiFp(this.configuration).currentHeight(options).then((request) => request(this.axios, this.basePath));
    }
}

export const BlockByEnum = {
    Commitment: 'commitment',
    Height: 'height'
} as const;
export type BlockByEnum = typeof BlockByEnum[keyof typeof BlockByEnum];
export const BlocksSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type BlocksSortEnum = typeof BlocksSortEnum[keyof typeof BlocksSortEnum];


/**
 * BridgeApi - axios parameter creator
 */
export const BridgeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get fast bridge info
         * @summary fastbridge_info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fastbridgeInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/fastbridge/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BridgeApi - functional programming interface
 */
export const BridgeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BridgeApiAxiosParamCreator(configuration)
    return {
        /**
         * Get fast bridge info
         * @summary fastbridge_info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fastbridgeInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespGetFastBridgeInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fastbridgeInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BridgeApi.fastbridgeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BridgeApi - factory interface
 */
export const BridgeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BridgeApiFp(configuration)
    return {
        /**
         * Get fast bridge info
         * @summary fastbridge_info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fastbridgeInfo(options?: RawAxiosRequestConfig): AxiosPromise<RespGetFastBridgeInfo> {
            return localVarFp.fastbridgeInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BridgeApi - object-oriented interface
 */
export class BridgeApi extends BaseAPI {
    /**
     * Get fast bridge info
     * @summary fastbridge_info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fastbridgeInfo(options?: RawAxiosRequestConfig) {
        return BridgeApiFp(this.configuration).fastbridgeInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CandlestickApi - axios parameter creator
 */
export const CandlestickApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get candlesticks
         * @summary candlesticks
         * @param {number} marketId 
         * @param {CandlesticksResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {boolean} [setTimestampToEnd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        candlesticks: async (marketId: number, resolution: CandlesticksResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, setTimestampToEnd?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('candlesticks', 'marketId', marketId)
            // verify required parameter 'resolution' is not null or undefined
            assertParamExists('candlesticks', 'resolution', resolution)
            // verify required parameter 'startTimestamp' is not null or undefined
            assertParamExists('candlesticks', 'startTimestamp', startTimestamp)
            // verify required parameter 'endTimestamp' is not null or undefined
            assertParamExists('candlesticks', 'endTimestamp', endTimestamp)
            // verify required parameter 'countBack' is not null or undefined
            assertParamExists('candlesticks', 'countBack', countBack)
            const localVarPath = `/api/v1/candlesticks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }

            if (countBack !== undefined) {
                localVarQueryParameter['count_back'] = countBack;
            }

            if (setTimestampToEnd !== undefined) {
                localVarQueryParameter['set_timestamp_to_end'] = setTimestampToEnd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get fundings
         * @summary fundings
         * @param {number} marketId 
         * @param {FundingsResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundings: async (marketId: number, resolution: FundingsResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('fundings', 'marketId', marketId)
            // verify required parameter 'resolution' is not null or undefined
            assertParamExists('fundings', 'resolution', resolution)
            // verify required parameter 'startTimestamp' is not null or undefined
            assertParamExists('fundings', 'startTimestamp', startTimestamp)
            // verify required parameter 'endTimestamp' is not null or undefined
            assertParamExists('fundings', 'endTimestamp', endTimestamp)
            // verify required parameter 'countBack' is not null or undefined
            assertParamExists('fundings', 'countBack', countBack)
            const localVarPath = `/api/v1/fundings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }

            if (countBack !== undefined) {
                localVarQueryParameter['count_back'] = countBack;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CandlestickApi - functional programming interface
 */
export const CandlestickApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CandlestickApiAxiosParamCreator(configuration)
    return {
        /**
         * Get candlesticks
         * @summary candlesticks
         * @param {number} marketId 
         * @param {CandlesticksResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {boolean} [setTimestampToEnd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async candlesticks(marketId: number, resolution: CandlesticksResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, setTimestampToEnd?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Candlesticks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.candlesticks(marketId, resolution, startTimestamp, endTimestamp, countBack, setTimestampToEnd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CandlestickApi.candlesticks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get fundings
         * @summary fundings
         * @param {number} marketId 
         * @param {FundingsResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fundings(marketId: number, resolution: FundingsResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fundings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fundings(marketId, resolution, startTimestamp, endTimestamp, countBack, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CandlestickApi.fundings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CandlestickApi - factory interface
 */
export const CandlestickApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CandlestickApiFp(configuration)
    return {
        /**
         * Get candlesticks
         * @summary candlesticks
         * @param {number} marketId 
         * @param {CandlesticksResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {boolean} [setTimestampToEnd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        candlesticks(marketId: number, resolution: CandlesticksResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, setTimestampToEnd?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Candlesticks> {
            return localVarFp.candlesticks(marketId, resolution, startTimestamp, endTimestamp, countBack, setTimestampToEnd, options).then((request) => request(axios, basePath));
        },
        /**
         * Get fundings
         * @summary fundings
         * @param {number} marketId 
         * @param {FundingsResolutionEnum} resolution 
         * @param {number} startTimestamp 
         * @param {number} endTimestamp 
         * @param {number} countBack 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundings(marketId: number, resolution: FundingsResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, options?: RawAxiosRequestConfig): AxiosPromise<Fundings> {
            return localVarFp.fundings(marketId, resolution, startTimestamp, endTimestamp, countBack, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CandlestickApi - object-oriented interface
 */
export class CandlestickApi extends BaseAPI {
    /**
     * Get candlesticks
     * @summary candlesticks
     * @param {number} marketId 
     * @param {CandlesticksResolutionEnum} resolution 
     * @param {number} startTimestamp 
     * @param {number} endTimestamp 
     * @param {number} countBack 
     * @param {boolean} [setTimestampToEnd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public candlesticks(marketId: number, resolution: CandlesticksResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, setTimestampToEnd?: boolean, options?: RawAxiosRequestConfig) {
        return CandlestickApiFp(this.configuration).candlesticks(marketId, resolution, startTimestamp, endTimestamp, countBack, setTimestampToEnd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get fundings
     * @summary fundings
     * @param {number} marketId 
     * @param {FundingsResolutionEnum} resolution 
     * @param {number} startTimestamp 
     * @param {number} endTimestamp 
     * @param {number} countBack 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fundings(marketId: number, resolution: FundingsResolutionEnum, startTimestamp: number, endTimestamp: number, countBack: number, options?: RawAxiosRequestConfig) {
        return CandlestickApiFp(this.configuration).fundings(marketId, resolution, startTimestamp, endTimestamp, countBack, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CandlesticksResolutionEnum = {
    _1m: '1m',
    _5m: '5m',
    _15m: '15m',
    _1h: '1h',
    _4h: '4h',
    _1d: '1d'
} as const;
export type CandlesticksResolutionEnum = typeof CandlesticksResolutionEnum[keyof typeof CandlesticksResolutionEnum];
export const FundingsResolutionEnum = {
    _1h: '1h',
    _1d: '1d'
} as const;
export type FundingsResolutionEnum = typeof FundingsResolutionEnum[keyof typeof FundingsResolutionEnum];


/**
 * FundingApi - axios parameter creator
 */
export const FundingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get funding rates
         * @summary funding-rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundingRates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/funding-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundingApi - functional programming interface
 */
export const FundingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundingApiAxiosParamCreator(configuration)
    return {
        /**
         * Get funding rates
         * @summary funding-rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fundingRates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundingRates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fundingRates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingApi.fundingRates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FundingApi - factory interface
 */
export const FundingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundingApiFp(configuration)
    return {
        /**
         * Get funding rates
         * @summary funding-rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundingRates(options?: RawAxiosRequestConfig): AxiosPromise<FundingRates> {
            return localVarFp.fundingRates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundingApi - object-oriented interface
 */
export class FundingApi extends BaseAPI {
    /**
     * Get funding rates
     * @summary funding-rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fundingRates(options?: RawAxiosRequestConfig) {
        return FundingApiFp(this.configuration).fundingRates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transfer fee info
         * @summary transferFeeInfo
         * @param {number} accountIndex 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [toAccountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferFeeInfo: async (accountIndex: number, authorization?: string, auth?: string, toAccountIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('transferFeeInfo', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/transferFeeInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (toAccountIndex !== undefined) {
                localVarQueryParameter['to_account_index'] = toAccountIndex;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdrawal delay in seconds
         * @summary withdrawalDelay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalDelay: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/withdrawalDelay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Transfer fee info
         * @summary transferFeeInfo
         * @param {number} accountIndex 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [toAccountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferFeeInfo(accountIndex: number, authorization?: string, auth?: string, toAccountIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferFeeInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferFeeInfo(accountIndex, authorization, auth, toAccountIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.transferFeeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Withdrawal delay in seconds
         * @summary withdrawalDelay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalDelay(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespWithdrawalDelay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalDelay(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.withdrawalDelay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         * Transfer fee info
         * @summary transferFeeInfo
         * @param {number} accountIndex 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [toAccountIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferFeeInfo(accountIndex: number, authorization?: string, auth?: string, toAccountIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransferFeeInfo> {
            return localVarFp.transferFeeInfo(accountIndex, authorization, auth, toAccountIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdrawal delay in seconds
         * @summary withdrawalDelay
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalDelay(options?: RawAxiosRequestConfig): AxiosPromise<RespWithdrawalDelay> {
            return localVarFp.withdrawalDelay(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 */
export class InfoApi extends BaseAPI {
    /**
     * Transfer fee info
     * @summary transferFeeInfo
     * @param {number} accountIndex 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {number} [toAccountIndex] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transferFeeInfo(accountIndex: number, authorization?: string, auth?: string, toAccountIndex?: number, options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).transferFeeInfo(accountIndex, authorization, auth, toAccountIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdrawal delay in seconds
     * @summary withdrawalDelay
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdrawalDelay(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).withdrawalDelay(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ack notification
         * @summary notification_ack
         * @param {string} notifId 
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationAck: async (notifId: string, accountIndex: number, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notifId' is not null or undefined
            assertParamExists('notificationAck', 'notifId', notifId)
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('notificationAck', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/notification/ack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (notifId !== undefined) { 
                localVarFormParams.append('notif_id', notifId as any);
            }
    
            if (auth !== undefined) { 
                localVarFormParams.append('auth', auth as any);
            }
    
            if (accountIndex !== undefined) { 
                localVarFormParams.append('account_index', accountIndex as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Ack notification
         * @summary notification_ack
         * @param {string} notifId 
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationAck(notifId: string, accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationAck(notifId, accountIndex, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.notificationAck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Ack notification
         * @summary notification_ack
         * @param {string} notifId 
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationAck(notifId: string, accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResultCode> {
            return localVarFp.notificationAck(notifId, accountIndex, authorization, auth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 */
export class NotificationApi extends BaseAPI {
    /**
     * Ack notification
     * @summary notification_ack
     * @param {string} notifId 
     * @param {number} accountIndex 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationAck(notifId: string, accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).notificationAck(notifId, accountIndex, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export data
         * @summary export
         * @param {ExportTypeEnum} type 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [accountIndex] 
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (type: ExportTypeEnum, authorization?: string, auth?: string, accountIndex?: number, marketId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('_export', 'type', type)
            const localVarPath = `/api/v1/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account active orders. `auth` can be generated using the SDK.
         * @summary accountActiveOrders
         * @param {number} accountIndex 
         * @param {number} marketId 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountActiveOrders: async (accountIndex: number, marketId: number, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('accountActiveOrders', 'accountIndex', accountIndex)
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('accountActiveOrders', 'marketId', marketId)
            const localVarPath = `/api/v1/accountActiveOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account inactive orders
         * @summary accountInactiveOrders
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {number} [askFilter] 
         * @param {string} [betweenTimestamps] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInactiveOrders: async (accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, askFilter?: number, betweenTimestamps?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('accountInactiveOrders', 'accountIndex', accountIndex)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('accountInactiveOrders', 'limit', limit)
            const localVarPath = `/api/v1/accountInactiveOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (askFilter !== undefined) {
                localVarQueryParameter['ask_filter'] = askFilter;
            }

            if (betweenTimestamps !== undefined) {
                localVarQueryParameter['between_timestamps'] = betweenTimestamps;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exchange stats
         * @summary exchangeStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/exchangeStats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order books metadata
         * @summary orderBookDetails
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBookDetails: async (marketId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orderBookDetails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order book orders
         * @summary orderBookOrders
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBookOrders: async (marketId: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('orderBookOrders', 'marketId', marketId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('orderBookOrders', 'limit', limit)
            const localVarPath = `/api/v1/orderBookOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.
         * @summary orderBooks
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBooks: async (marketId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orderBooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent trades
         * @summary recentTrades
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentTrades: async (marketId: number, limit: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            assertParamExists('recentTrades', 'marketId', marketId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('recentTrades', 'limit', limit)
            const localVarPath = `/api/v1/recentTrades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get trades
         * @summary trades
         * @param {TradesSortByEnum} sortBy 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {number} [accountIndex] 
         * @param {number} [orderIndex] 
         * @param {TradesSortDirEnum} [sortDir] 
         * @param {string} [cursor] 
         * @param {number} [from] 
         * @param {number} [askFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trades: async (sortBy: TradesSortByEnum, limit: number, authorization?: string, auth?: string, marketId?: number, accountIndex?: number, orderIndex?: number, sortDir?: TradesSortDirEnum, cursor?: string, from?: number, askFilter?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('trades', 'sortBy', sortBy)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('trades', 'limit', limit)
            const localVarPath = `/api/v1/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (marketId !== undefined) {
                localVarQueryParameter['market_id'] = marketId;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (orderIndex !== undefined) {
                localVarQueryParameter['order_index'] = orderIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (askFilter !== undefined) {
                localVarQueryParameter['ask_filter'] = askFilter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Export data
         * @summary export
         * @param {ExportTypeEnum} type 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [accountIndex] 
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(type: ExportTypeEnum, authorization?: string, auth?: string, accountIndex?: number, marketId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(type, authorization, auth, accountIndex, marketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi._export']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account active orders. `auth` can be generated using the SDK.
         * @summary accountActiveOrders
         * @param {number} accountIndex 
         * @param {number} marketId 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountActiveOrders(accountIndex: number, marketId: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orders>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountActiveOrders(accountIndex, marketId, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.accountActiveOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account inactive orders
         * @summary accountInactiveOrders
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {number} [askFilter] 
         * @param {string} [betweenTimestamps] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountInactiveOrders(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, askFilter?: number, betweenTimestamps?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Orders>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountInactiveOrders(accountIndex, limit, authorization, auth, marketId, askFilter, betweenTimestamps, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.accountInactiveOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get exchange stats
         * @summary exchangeStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangeStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangeStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.exchangeStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order books metadata
         * @summary orderBookDetails
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderBookDetails(marketId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderBookDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderBookDetails(marketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderBookDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order book orders
         * @summary orderBookOrders
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderBookOrders(marketId: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderBookOrders>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderBookOrders(marketId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderBookOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.
         * @summary orderBooks
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderBooks(marketId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderBooks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderBooks(marketId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent trades
         * @summary recentTrades
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentTrades(marketId: number, limit: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trades>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentTrades(marketId, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.recentTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get trades
         * @summary trades
         * @param {TradesSortByEnum} sortBy 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {number} [accountIndex] 
         * @param {number} [orderIndex] 
         * @param {TradesSortDirEnum} [sortDir] 
         * @param {string} [cursor] 
         * @param {number} [from] 
         * @param {number} [askFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trades(sortBy: TradesSortByEnum, limit: number, authorization?: string, auth?: string, marketId?: number, accountIndex?: number, orderIndex?: number, sortDir?: TradesSortDirEnum, cursor?: string, from?: number, askFilter?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trades>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trades(sortBy, limit, authorization, auth, marketId, accountIndex, orderIndex, sortDir, cursor, from, askFilter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.trades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * Export data
         * @summary export
         * @param {ExportTypeEnum} type 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [accountIndex] 
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(type: ExportTypeEnum, authorization?: string, auth?: string, accountIndex?: number, marketId?: number, options?: RawAxiosRequestConfig): AxiosPromise<ExportData> {
            return localVarFp._export(type, authorization, auth, accountIndex, marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account active orders. `auth` can be generated using the SDK.
         * @summary accountActiveOrders
         * @param {number} accountIndex 
         * @param {number} marketId 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountActiveOrders(accountIndex: number, marketId: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<Orders> {
            return localVarFp.accountActiveOrders(accountIndex, marketId, authorization, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account inactive orders
         * @summary accountInactiveOrders
         * @param {number} accountIndex 
         * @param {number} limit 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {number} [marketId] 
         * @param {number} [askFilter] 
         * @param {string} [betweenTimestamps] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInactiveOrders(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, askFilter?: number, betweenTimestamps?: string, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<Orders> {
            return localVarFp.accountInactiveOrders(accountIndex, limit, authorization, auth, marketId, askFilter, betweenTimestamps, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get exchange stats
         * @summary exchangeStats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangeStats(options?: RawAxiosRequestConfig): AxiosPromise<ExchangeStats> {
            return localVarFp.exchangeStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Get order books metadata
         * @summary orderBookDetails
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBookDetails(marketId?: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderBookDetails> {
            return localVarFp.orderBookDetails(marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order book orders
         * @summary orderBookOrders
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBookOrders(marketId: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderBookOrders> {
            return localVarFp.orderBookOrders(marketId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.
         * @summary orderBooks
         * @param {number} [marketId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBooks(marketId?: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderBooks> {
            return localVarFp.orderBooks(marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent trades
         * @summary recentTrades
         * @param {number} marketId 
         * @param {number} limit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentTrades(marketId: number, limit: number, options?: RawAxiosRequestConfig): AxiosPromise<Trades> {
            return localVarFp.recentTrades(marketId, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get trades
         * @summary trades
         * @param {TradesSortByEnum} sortBy 
         * @param {number} limit 
         * @param {string} [authorization] 
         * @param {string} [auth] 
         * @param {number} [marketId] 
         * @param {number} [accountIndex] 
         * @param {number} [orderIndex] 
         * @param {TradesSortDirEnum} [sortDir] 
         * @param {string} [cursor] 
         * @param {number} [from] 
         * @param {number} [askFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trades(sortBy: TradesSortByEnum, limit: number, authorization?: string, auth?: string, marketId?: number, accountIndex?: number, orderIndex?: number, sortDir?: TradesSortDirEnum, cursor?: string, from?: number, askFilter?: number, options?: RawAxiosRequestConfig): AxiosPromise<Trades> {
            return localVarFp.trades(sortBy, limit, authorization, auth, marketId, accountIndex, orderIndex, sortDir, cursor, from, askFilter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /**
     * Export data
     * @summary export
     * @param {ExportTypeEnum} type 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {number} [accountIndex] 
     * @param {number} [marketId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _export(type: ExportTypeEnum, authorization?: string, auth?: string, accountIndex?: number, marketId?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration)._export(type, authorization, auth, accountIndex, marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account active orders. `auth` can be generated using the SDK.
     * @summary accountActiveOrders
     * @param {number} accountIndex 
     * @param {number} marketId 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountActiveOrders(accountIndex: number, marketId: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).accountActiveOrders(accountIndex, marketId, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account inactive orders
     * @summary accountInactiveOrders
     * @param {number} accountIndex 
     * @param {number} limit 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {number} [marketId] 
     * @param {number} [askFilter] 
     * @param {string} [betweenTimestamps] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountInactiveOrders(accountIndex: number, limit: number, authorization?: string, auth?: string, marketId?: number, askFilter?: number, betweenTimestamps?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).accountInactiveOrders(accountIndex, limit, authorization, auth, marketId, askFilter, betweenTimestamps, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get exchange stats
     * @summary exchangeStats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exchangeStats(options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).exchangeStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order books metadata
     * @summary orderBookDetails
     * @param {number} [marketId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderBookDetails(marketId?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderBookDetails(marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order book orders
     * @summary orderBookOrders
     * @param {number} marketId 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderBookOrders(marketId: number, limit: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderBookOrders(marketId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.
     * @summary orderBooks
     * @param {number} [marketId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public orderBooks(marketId?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderBooks(marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent trades
     * @summary recentTrades
     * @param {number} marketId 
     * @param {number} limit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recentTrades(marketId: number, limit: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).recentTrades(marketId, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get trades
     * @summary trades
     * @param {TradesSortByEnum} sortBy 
     * @param {number} limit 
     * @param {string} [authorization] 
     * @param {string} [auth] 
     * @param {number} [marketId] 
     * @param {number} [accountIndex] 
     * @param {number} [orderIndex] 
     * @param {TradesSortDirEnum} [sortDir] 
     * @param {string} [cursor] 
     * @param {number} [from] 
     * @param {number} [askFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public trades(sortBy: TradesSortByEnum, limit: number, authorization?: string, auth?: string, marketId?: number, accountIndex?: number, orderIndex?: number, sortDir?: TradesSortDirEnum, cursor?: string, from?: number, askFilter?: number, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).trades(sortBy, limit, authorization, auth, marketId, accountIndex, orderIndex, sortDir, cursor, from, askFilter, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ExportTypeEnum = {
    Funding: 'funding',
    Trade: 'trade'
} as const;
export type ExportTypeEnum = typeof ExportTypeEnum[keyof typeof ExportTypeEnum];
export const TradesSortByEnum = {
    BlockHeight: 'block_height',
    Timestamp: 'timestamp',
    TradeId: 'trade_id'
} as const;
export type TradesSortByEnum = typeof TradesSortByEnum[keyof typeof TradesSortByEnum];
export const TradesSortDirEnum = {
    Desc: 'desc'
} as const;
export type TradesSortDirEnum = typeof TradesSortDirEnum[keyof typeof TradesSortDirEnum];


/**
 * ReferralApi - axios parameter creator
 */
export const ReferralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get referral points
         * @summary referral_points
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralPoints: async (accountIndex: number, authorization?: string, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('referralPoints', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/referral/points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferralApi - functional programming interface
 */
export const ReferralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferralApiAxiosParamCreator(configuration)
    return {
        /**
         * Get referral points
         * @summary referral_points
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referralPoints(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReferralPoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referralPoints(accountIndex, authorization, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReferralApi.referralPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReferralApi - factory interface
 */
export const ReferralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferralApiFp(configuration)
    return {
        /**
         * Get referral points
         * @summary referral_points
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referralPoints(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReferralPoints> {
            return localVarFp.referralPoints(accountIndex, authorization, auth, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferralApi - object-oriented interface
 */
export class ReferralApi extends BaseAPI {
    /**
     * Get referral points
     * @summary referral_points
     * @param {number} accountIndex 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public referralPoints(accountIndex: number, authorization?: string, auth?: string, options?: RawAxiosRequestConfig) {
        return ReferralApiFp(this.configuration).referralPoints(accountIndex, authorization, auth, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootApi - axios parameter creator
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get info of zklighter
         * @summary info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get status of zklighter
         * @summary status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         * Get info of zklighter
         * @summary info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZkLighterInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootApi.info']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get status of zklighter
         * @summary status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async status(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.status(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootApi.status']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RootApi - factory interface
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         * Get info of zklighter
         * @summary info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(options?: RawAxiosRequestConfig): AxiosPromise<ZkLighterInfo> {
            return localVarFp.info(options).then((request) => request(axios, basePath));
        },
        /**
         * Get status of zklighter
         * @summary status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        status(options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.status(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 */
export class RootApi extends BaseAPI {
    /**
     * Get info of zklighter
     * @summary info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public info(options?: RawAxiosRequestConfig) {
        return RootApiFp(this.configuration).info(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get status of zklighter
     * @summary status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public status(options?: RawAxiosRequestConfig) {
        return RootApiFp(this.configuration).status(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get transactions of a specific account
         * @summary accountTxs
         * @param {number} limit 
         * @param {AccountTxsByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {number} [index] 
         * @param {Array<number>} [types] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTxs: async (limit: number, by: AccountTxsByEnum, value: string, authorization?: string, index?: number, types?: Array<number>, auth?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('accountTxs', 'limit', limit)
            // verify required parameter 'by' is not null or undefined
            assertParamExists('accountTxs', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('accountTxs', 'value', value)
            const localVarPath = `/api/v1/accountTxs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (types) {
                localVarQueryParameter['types'] = types.join(COLLECTION_FORMATS.csv);
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transactions in a block
         * @summary blockTxs
         * @param {BlockTxsByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockTxs: async (by: BlockTxsByEnum, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('blockTxs', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('blockTxs', 'value', value)
            const localVarPath = `/api/v1/blockTxs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deposit history
         * @summary deposit_history
         * @param {number} accountIndex 
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {DepositHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositHistory: async (accountIndex: number, l1Address: string, authorization?: string, auth?: string, cursor?: string, filter?: DepositHistoryFilterEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('depositHistory', 'accountIndex', accountIndex)
            // verify required parameter 'l1Address' is not null or undefined
            assertParamExists('depositHistory', 'l1Address', l1Address)
            const localVarPath = `/api/v1/deposit/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (l1Address !== undefined) {
                localVarQueryParameter['l1_address'] = l1Address;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get next nonce for a specific account and api key
         * @summary nextNonce
         * @param {number} accountIndex 
         * @param {number} apiKeyIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextNonce: async (accountIndex: number, apiKeyIndex: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('nextNonce', 'accountIndex', accountIndex)
            // verify required parameter 'apiKeyIndex' is not null or undefined
            assertParamExists('nextNonce', 'apiKeyIndex', apiKeyIndex)
            const localVarPath = `/api/v1/nextNonce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (apiKeyIndex !== undefined) {
                localVarQueryParameter['api_key_index'] = apiKeyIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTx
         * @param {number} txType 
         * @param {string} txInfo 
         * @param {boolean} [priceProtection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx: async (txType: number, txInfo: string, priceProtection?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txType' is not null or undefined
            assertParamExists('sendTx', 'txType', txType)
            // verify required parameter 'txInfo' is not null or undefined
            assertParamExists('sendTx', 'txInfo', txInfo)
            const localVarPath = `/api/v1/sendTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (txType !== undefined) { 
                localVarFormParams.append('tx_type', txType as any);
            }
    
            if (txInfo !== undefined) { 
                localVarFormParams.append('tx_info', txInfo as any);
            }
    
            if (priceProtection !== undefined) { 
                localVarFormParams.append('price_protection', String(priceProtection) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTxBatch
         * @param {string} txTypes 
         * @param {string} txInfos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTxBatch: async (txTypes: string, txInfos: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'txTypes' is not null or undefined
            assertParamExists('sendTxBatch', 'txTypes', txTypes)
            // verify required parameter 'txInfos' is not null or undefined
            assertParamExists('sendTxBatch', 'txInfos', txInfos)
            const localVarPath = `/api/v1/sendTxBatch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (txTypes !== undefined) { 
                localVarFormParams.append('tx_types', txTypes as any);
            }
    
            if (txInfos !== undefined) { 
                localVarFormParams.append('tx_infos', txInfos as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transfer history
         * @summary transfer_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferHistory: async (accountIndex: number, authorization?: string, auth?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('transferHistory', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/transfer/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transaction by hash or sequence index
         * @summary tx
         * @param {TxByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx: async (by: TxByEnum, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'by' is not null or undefined
            assertParamExists('tx', 'by', by)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('tx', 'value', value)
            const localVarPath = `/api/v1/tx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (by !== undefined) {
                localVarQueryParameter['by'] = by;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get L1 transaction by L1 transaction hash
         * @summary txFromL1TxHash
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txFromL1TxHash: async (hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txFromL1TxHash', 'hash', hash)
            const localVarPath = `/api/v1/txFromL1TxHash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transactions which are already packed into blocks
         * @summary txs
         * @param {number} limit 
         * @param {number} [index] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txs: async (limit: number, index?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('txs', 'limit', limit)
            const localVarPath = `/api/v1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get withdraw history
         * @summary withdraw_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {WithdrawHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawHistory: async (accountIndex: number, authorization?: string, auth?: string, cursor?: string, filter?: WithdrawHistoryFilterEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIndex' is not null or undefined
            assertParamExists('withdrawHistory', 'accountIndex', accountIndex)
            const localVarPath = `/api/v1/withdraw/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIndex !== undefined) {
                localVarQueryParameter['account_index'] = accountIndex;
            }

            if (auth !== undefined) {
                localVarQueryParameter['auth'] = auth;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get transactions of a specific account
         * @summary accountTxs
         * @param {number} limit 
         * @param {AccountTxsByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {number} [index] 
         * @param {Array<number>} [types] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountTxs(limit: number, by: AccountTxsByEnum, value: string, authorization?: string, index?: number, types?: Array<number>, auth?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Txs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountTxs(limit, by, value, authorization, index, types, auth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.accountTxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transactions in a block
         * @summary blockTxs
         * @param {BlockTxsByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockTxs(by: BlockTxsByEnum, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Txs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockTxs(by, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.blockTxs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get deposit history
         * @summary deposit_history
         * @param {number} accountIndex 
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {DepositHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositHistory(accountIndex: number, l1Address: string, authorization?: string, auth?: string, cursor?: string, filter?: DepositHistoryFilterEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.depositHistory(accountIndex, l1Address, authorization, auth, cursor, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.depositHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get next nonce for a specific account and api key
         * @summary nextNonce
         * @param {number} accountIndex 
         * @param {number} apiKeyIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nextNonce(accountIndex: number, apiKeyIndex: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NextNonce>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nextNonce(accountIndex, apiKeyIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.nextNonce']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTx
         * @param {number} txType 
         * @param {string} txInfo 
         * @param {boolean} [priceProtection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTx(txType: number, txInfo: string, priceProtection?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespSendTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTx(txType, txInfo, priceProtection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.sendTx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTxBatch
         * @param {string} txTypes 
         * @param {string} txInfos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTxBatch(txTypes: string, txInfos: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespSendTxBatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTxBatch(txTypes, txInfos, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.sendTxBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transfer history
         * @summary transfer_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransferHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferHistory(accountIndex, authorization, auth, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transferHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transaction by hash or sequence index
         * @summary tx
         * @param {TxByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tx(by: TxByEnum, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnrichedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tx(by, value, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.tx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get L1 transaction by L1 transaction hash
         * @summary txFromL1TxHash
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txFromL1TxHash(hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnrichedTx>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txFromL1TxHash(hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.txFromL1TxHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get transactions which are already packed into blocks
         * @summary txs
         * @param {number} limit 
         * @param {number} [index] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txs(limit: number, index?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Txs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txs(limit, index, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.txs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get withdraw history
         * @summary withdraw_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {WithdrawHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, filter?: WithdrawHistoryFilterEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawHistory(accountIndex, authorization, auth, cursor, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.withdrawHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Get transactions of a specific account
         * @summary accountTxs
         * @param {number} limit 
         * @param {AccountTxsByEnum} by 
         * @param {string} value 
         * @param {string} [authorization] 
         * @param {number} [index] 
         * @param {Array<number>} [types] 
         * @param {string} [auth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTxs(limit: number, by: AccountTxsByEnum, value: string, authorization?: string, index?: number, types?: Array<number>, auth?: string, options?: RawAxiosRequestConfig): AxiosPromise<Txs> {
            return localVarFp.accountTxs(limit, by, value, authorization, index, types, auth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transactions in a block
         * @summary blockTxs
         * @param {BlockTxsByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockTxs(by: BlockTxsByEnum, value: string, options?: RawAxiosRequestConfig): AxiosPromise<Txs> {
            return localVarFp.blockTxs(by, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deposit history
         * @summary deposit_history
         * @param {number} accountIndex 
         * @param {string} l1Address 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {DepositHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositHistory(accountIndex: number, l1Address: string, authorization?: string, auth?: string, cursor?: string, filter?: DepositHistoryFilterEnum, options?: RawAxiosRequestConfig): AxiosPromise<DepositHistory> {
            return localVarFp.depositHistory(accountIndex, l1Address, authorization, auth, cursor, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get next nonce for a specific account and api key
         * @summary nextNonce
         * @param {number} accountIndex 
         * @param {number} apiKeyIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nextNonce(accountIndex: number, apiKeyIndex: number, options?: RawAxiosRequestConfig): AxiosPromise<NextNonce> {
            return localVarFp.nextNonce(accountIndex, apiKeyIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTx
         * @param {number} txType 
         * @param {string} txInfo 
         * @param {boolean} [priceProtection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTx(txType: number, txInfo: string, priceProtection?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<RespSendTx> {
            return localVarFp.sendTx(txType, txInfo, priceProtection, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
         * @summary sendTxBatch
         * @param {string} txTypes 
         * @param {string} txInfos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTxBatch(txTypes: string, txInfos: string, options?: RawAxiosRequestConfig): AxiosPromise<RespSendTxBatch> {
            return localVarFp.sendTxBatch(txTypes, txInfos, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transfer history
         * @summary transfer_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<TransferHistory> {
            return localVarFp.transferHistory(accountIndex, authorization, auth, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction by hash or sequence index
         * @summary tx
         * @param {TxByEnum} by 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tx(by: TxByEnum, value: string, options?: RawAxiosRequestConfig): AxiosPromise<EnrichedTx> {
            return localVarFp.tx(by, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get L1 transaction by L1 transaction hash
         * @summary txFromL1TxHash
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txFromL1TxHash(hash: string, options?: RawAxiosRequestConfig): AxiosPromise<EnrichedTx> {
            return localVarFp.txFromL1TxHash(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transactions which are already packed into blocks
         * @summary txs
         * @param {number} limit 
         * @param {number} [index] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txs(limit: number, index?: number, options?: RawAxiosRequestConfig): AxiosPromise<Txs> {
            return localVarFp.txs(limit, index, options).then((request) => request(axios, basePath));
        },
        /**
         * Get withdraw history
         * @summary withdraw_history
         * @param {number} accountIndex 
         * @param {string} [authorization]  make required after integ is done
         * @param {string} [auth]  made optional to support header auth clients
         * @param {string} [cursor] 
         * @param {WithdrawHistoryFilterEnum} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, filter?: WithdrawHistoryFilterEnum, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawHistory> {
            return localVarFp.withdrawHistory(accountIndex, authorization, auth, cursor, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 */
export class TransactionApi extends BaseAPI {
    /**
     * Get transactions of a specific account
     * @summary accountTxs
     * @param {number} limit 
     * @param {AccountTxsByEnum} by 
     * @param {string} value 
     * @param {string} [authorization] 
     * @param {number} [index] 
     * @param {Array<number>} [types] 
     * @param {string} [auth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public accountTxs(limit: number, by: AccountTxsByEnum, value: string, authorization?: string, index?: number, types?: Array<number>, auth?: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).accountTxs(limit, by, value, authorization, index, types, auth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transactions in a block
     * @summary blockTxs
     * @param {BlockTxsByEnum} by 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public blockTxs(by: BlockTxsByEnum, value: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).blockTxs(by, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deposit history
     * @summary deposit_history
     * @param {number} accountIndex 
     * @param {string} l1Address 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {string} [cursor] 
     * @param {DepositHistoryFilterEnum} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public depositHistory(accountIndex: number, l1Address: string, authorization?: string, auth?: string, cursor?: string, filter?: DepositHistoryFilterEnum, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).depositHistory(accountIndex, l1Address, authorization, auth, cursor, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get next nonce for a specific account and api key
     * @summary nextNonce
     * @param {number} accountIndex 
     * @param {number} apiKeyIndex 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public nextNonce(accountIndex: number, apiKeyIndex: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).nextNonce(accountIndex, apiKeyIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
     * @summary sendTx
     * @param {number} txType 
     * @param {string} txInfo 
     * @param {boolean} [priceProtection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendTx(txType: number, txInfo: string, priceProtection?: boolean, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).sendTx(txType, txInfo, priceProtection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)
     * @summary sendTxBatch
     * @param {string} txTypes 
     * @param {string} txInfos 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendTxBatch(txTypes: string, txInfos: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).sendTxBatch(txTypes, txInfos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transfer history
     * @summary transfer_history
     * @param {number} accountIndex 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transferHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transferHistory(accountIndex, authorization, auth, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transaction by hash or sequence index
     * @summary tx
     * @param {TxByEnum} by 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tx(by: TxByEnum, value: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).tx(by, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get L1 transaction by L1 transaction hash
     * @summary txFromL1TxHash
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public txFromL1TxHash(hash: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).txFromL1TxHash(hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transactions which are already packed into blocks
     * @summary txs
     * @param {number} limit 
     * @param {number} [index] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public txs(limit: number, index?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).txs(limit, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get withdraw history
     * @summary withdraw_history
     * @param {number} accountIndex 
     * @param {string} [authorization]  make required after integ is done
     * @param {string} [auth]  made optional to support header auth clients
     * @param {string} [cursor] 
     * @param {WithdrawHistoryFilterEnum} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdrawHistory(accountIndex: number, authorization?: string, auth?: string, cursor?: string, filter?: WithdrawHistoryFilterEnum, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).withdrawHistory(accountIndex, authorization, auth, cursor, filter, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AccountTxsByEnum = {
    AccountIndex: 'account_index'
} as const;
export type AccountTxsByEnum = typeof AccountTxsByEnum[keyof typeof AccountTxsByEnum];
export const BlockTxsByEnum = {
    BlockHeight: 'block_height',
    BlockCommitment: 'block_commitment'
} as const;
export type BlockTxsByEnum = typeof BlockTxsByEnum[keyof typeof BlockTxsByEnum];
export const DepositHistoryFilterEnum = {
    All: 'all',
    Pending: 'pending',
    Claimable: 'claimable'
} as const;
export type DepositHistoryFilterEnum = typeof DepositHistoryFilterEnum[keyof typeof DepositHistoryFilterEnum];
export const TxByEnum = {
    Hash: 'hash',
    SequenceIndex: 'sequence_index'
} as const;
export type TxByEnum = typeof TxByEnum[keyof typeof TxByEnum];
export const WithdrawHistoryFilterEnum = {
    All: 'all',
    Pending: 'pending',
    Claimable: 'claimable'
} as const;
export type WithdrawHistoryFilterEnum = typeof WithdrawHistoryFilterEnum[keyof typeof WithdrawHistoryFilterEnum];


